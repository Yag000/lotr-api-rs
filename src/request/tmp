
/// This enum represents all the different types of requests that can be made to the API.
/// It is used to get the url for the request.
///

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Request {
    /// Request containing a filter.
    Filter(FilterReq),
    /// Request containing a sort.
    Sort(SortReq),
    /// Basic request, for example `book`, 'movie' or `character/{id}`.
    Get(GetReq),
    /// This corresponds to requests of the type `book/{id}/chapter` etc...
    Specific(SpecificReq),
}

impl Request {
    /// Returns the [`ItemType`] of the request.
    /// I the case of a Specific request, it returns the [`ItemType`] of the second item, since it
    /// is the type of object that is being requested.
    pub(crate) fn get_item_type(&self) -> ItemType {
        match self {
            Self::Filter(filter_req) => filter_req.get_req.item_type.clone(),
            Self::Sort(sort_req) => sort_req.get_req.item_type.clone(),
            Self::Get(get_req) => get_req.item_type.clone(),
            Self::Specific(specific_req) => specific_req.second_item.clone(),
        }
    }
}

impl GetUrl for Request {
    fn get_url(&self) -> String {
        match self {
            Request::Filter(filter_req) => filter_req.get_url(),
            Request::Sort(sort_req) => sort_req.get_url(),
            Request::Get(get_req) => get_req.get_url(),
            Request::Specific(specific_req) => specific_req.get_url(),
        }
    }
}

/// Request containing a filter.
///
/// # Example
/// ```
/// use lotr_api_wrapper::{ItemType,
///     attribute::{Attribute, BookAttribute},
///     request::{FilterReq, GetReq, GetUrl, filter::{Filter, Operator}}};
///
/// let filter = Filter::Match(Attribute::Book(BookAttribute::Name), Operator::Ne,vec!["The Fellowship of the Ring".to_string()]);
/// let request = FilterReq::new( filter);
///
/// assert_eq!(request.get_url(), "book?name!=The Fellowship of the Ring");
/// ```
///
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct FilterReq {
    get_req: GetReq,
    filter: Filter,
    pagination: Option<Pagination>,
}

impl FilterReq {
    pub fn new(filter: Filter) -> Self {
        let get_req = GetReq::new(filter.get_item_type());
        Self {
            get_req,
            filter,
            pagination: None,
        }
    }

    /// Create a new [`SortReq`] from a [`GetReq`] and a [`Sort`].
    /// In an ideal world this should never be called with a [`GetReq`] that
    /// has a item type that is different from the [`Sort`]'s sort by attribute.
    /// Since this is not the case, we must make sure that the item type of the
    /// [`GetReq`] is the same as the [`Sort`]'s sort by attribute. If it not he case
    /// we return an error.
    ///
    /// # Example
    ///
    /// ```
    /// use lotr_api_wrapper::{ItemType,
    ///    attribute::{Attribute, BookAttribute},
    ///    request::{FilterReq, GetReq, GetUrl, filter::{Filter, Operator}}};
    ///
    /// let get_req = GetReq::new(ItemType::Book);
    /// let filter = Filter::Match(Attribute::Book(BookAttribute::Name), Operator::Ne,vec!["The Fellowship of the Ring".to_string()]);
    /// let request = FilterReq::from_get_req(get_req, filter).unwrap();
    ///
    /// assert_eq!(request.get_url(), "book?name!=The Fellowship of the Ring");
    ///
    ///
    /// // This should return an error as the item type of the GetReq is different from the sort by attribute.
    /// let get_req = GetReq::new(ItemType::Quote);
    /// let filter = Filter::Match(Attribute::Book(BookAttribute::Name), Operator::Ne,vec!["The Fellowship of the Ring".to_string()]);
    /// let request = FilterReq::from_get_req(get_req, filter);
    ///
    /// assert!(request.is_err());
    /// ```
    ///
    pub fn from_get_req(get_req: GetReq, filter: Filter) -> Result<Self, Error> {
        if get_req.item_type != filter.get_item_type() {
            Err(Error::new(
                "The item type of the GetReq is different from the sort by attribute".to_string(),
            ))
        } else {
            Ok(Self {
                get_req,
                filter,
                pagination: None,
            })
        }
    }
}

impl AddPagination for FilterReq {
    fn add_pagination(mut self, pagination: Pagination) -> Self {
        self.pagination = Some(pagination);
        self
    }
}

impl GetUrl for FilterReq {
    fn get_url(&self) -> String {
        let mut url = self.get_req.get_url();
        url.push_str(&format!("?{}", self.filter.get_url()));
        if let Some(pagination) = &self.pagination {
            url.push_str(&pagination.get_url());
        }
        url
    }
}

/// Request containing a sort.
///
/// # Example
///
/// ```
/// use lotr_api_wrapper::{ItemType,
///    attribute::{Attribute, BookAttribute},
///    request::{SortReq, GetReq, GetUrl, sort::{Sort, SortOrder}}};
///
/// let get_req = GetReq::new(ItemType::Book);
/// let sort = Sort::new(SortOrder::Ascending, Attribute::Book(BookAttribute::Name));
/// let request = SortReq::new(sort);
///
/// assert_eq!(request.get_url(), "book?sort=name:asc");
/// ```
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SortReq {
    get_req: GetReq,
    sort: Sort,
    pagination: Option<Pagination>,
}

impl SortReq {
    pub fn new(sort: Sort) -> Self {
        let item_type: ItemType = sort.get_item_type().into();
        let get_req = GetReq::new(item_type);
        Self {
            get_req,
            sort,
            pagination: None,
        }
    }

    /// Create a new [`SortReq`] from a [`GetReq`] and a [`Sort`].
    /// In an ideal world this should never be called with a [`GetReq`] that
    /// has a item type that is different from the [`Sort`]'s sort by attribute.
    /// Since this is not the case, we must make sure that the item type of the
    /// [`GetReq`] is the same as the [`Sort`]'s sort by attribute. If it not he case
    /// we return an error.
    ///
    /// # Example
    ///
    /// ```
    /// use lotr_api_wrapper::{ItemType,
    ///   attribute::{Attribute, BookAttribute},
    ///   request::{SortReq, GetReq, GetUrl, sort::{Sort, SortOrder}}};
    ///
    /// let get_req = GetReq::new(ItemType::Book);
    /// let sort = Sort::new(SortOrder::Ascending, Attribute::Book(BookAttribute::Name));
    /// let request = SortReq::from_get_req(get_req, sort).unwrap();\
    ///
    /// assert_eq!(request.get_url(), "book?sort=name:asc");
    ///
    /// // This should return an error as the item type of the GetReq is different from the sort by attribute.
    /// let get_req = GetReq::new(ItemType::Quote);
    /// let sort = Sort::new(SortOrder::Ascending, Attribute::Book(BookAttribute::Name));
    /// let request = SortReq::from_get_req(get_req, sort);
    ///
    /// assert!(request.is_err());
    /// ```
    ///
    pub fn from_get_req(get_req: GetReq, sort: Sort) -> Result<Self, Error> {
        if get_req.item_type != sort.get_item_type() {
            Err(Error::new(
                "The item type of the GetReq is different from the sort by attribute".to_string(),
            ))
        } else {
            Ok(Self {
                get_req,
                sort,
                pagination: None,
            })
        }
    }
}

impl AddPagination for SortReq {
    fn add_pagination(mut self, pagination: Pagination) -> Self {
        self.pagination = Some(pagination);
        self
    }
}

impl GetUrl for SortReq {
    fn get_url(&self) -> String {
        let mut url = self.get_req.get_url();
        url.push_str(&format!("?{}", self.sort.get_url()));
        if let Some(pagination) = &self.pagination {
            url.push_str(&pagination.get_url());
        }
        url
    }
}

/// Basic request, for example `book`, 'movie' or `character/{id}`.
///
/// # Example
///
/// ```
/// use lotr_api_wrapper::{ItemType, request::{GetReq, GetUrl}};
///
/// let get_req = GetReq::new(ItemType::Book);
///
/// assert_eq!(get_req.get_url(), "book");
/// ```
///
/// ```
/// use lotr_api_wrapper::{ItemType, request::{GetReq, GetUrl}};
///
// // The id is not a valid id, it is just an example.
/// let get_req = GetReq::new(ItemType::Character).id("123e1".to_string());
///
/// assert_eq!(get_req.get_url(), "character/123e1");
/// ```

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct GetReq {
    item_type: ItemType,
    id: Option<String>,
    pagination: Option<Pagination>,
}

impl AddPagination for GetReq {
    fn add_pagination(mut self, pagination: Pagination) -> Self {
        self.pagination = Some(pagination);
        self
    }
}

impl GetReq {
    pub fn new(item_type: ItemType) -> Self {
        Self {
            item_type,
            id: None,
            pagination: None,
        }
    }

    /// Set the id of the request.
    /// This is used for requests of the type `character/{id}`.
    ///
    /// # Example
    ///
    /// ```
    /// use lotr_api_wrapper::{ItemType, request::{GetReq, GetUrl}};
    ///
    /// let get_req = GetReq::new(ItemType::Character).id("character_id".to_string());
    ///
    /// assert_eq!(get_req.get_url(), "character/character_id");
    /// ```
    pub fn id(mut self, id: String) -> Self {
        self.id = Some(id);
        self
    }
}

impl GetUrl for GetReq {
    fn get_url(&self) -> String {
        let mut url = String::new();
        url.push_str(&self.item_type.get_url());
        if let Some(id) = &self.id {
            url.push('/');
            url.push_str(id);
        }
        if let Some(pagination) = &self.pagination {
            url.push_str(&pagination.get_url());
        }
        url
    }
}

/// This corresponds to requests of the type `book/{id}/chapter` or other
/// requests of the type `item/{id}/second_item`. They can not accept a
/// filter or a sort and that's why they are not included in the
/// ['GetReq'] struct.
///
/// # Example
///
/// ```
/// use lotr_api_wrapper::{ItemType,
///    request::{SpecificReq, GetReq, GetUrl}};
///
/// // The id is not a valid id, it is just an example.
/// let request = SpecificReq::new(GetReq::new(ItemType::Character).id("123e1".to_string()), ItemType::Quote);
///
/// assert_eq!(request.get_url(), "character/123e1/quote");
/// ```
///
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SpecificReq {
    get_req: GetReq,
    second_item: ItemType,
    pagination: Option<Pagination>,
}

impl SpecificReq {
    pub fn new(get_req: GetReq, second_item: ItemType) -> Self {
        Self {
            get_req,
            second_item,
            pagination: None,
        }
    }
}

impl GetUrl for SpecificReq {
    fn get_url(&self) -> String {
        let mut url = self.get_req.get_url();
        url.push_str(&format!("/{}", self.second_item.get_url()));
        if let Some(pagination) = &self.pagination {
            url.push_str(&pagination.get_url());
        }
        url
    }
}
